"""
Research Agent Example

Demonstrates:
1. A custom agent subclass (Researcher) with specialized calls for research queries.
2. A mock web search tool (WebSearchTool) that simulates tool calls.
3. A custom runtime implementation (ResearchRuntime) for managing an interactive research session.
4. Using a basic system prompt configuration instead of a full persona.

Key Concepts:
    - BaseAgent: Core class that handles conversation history, prompt composition, and tool usage.
    - Custom Agent Subclass: Researcher extends BaseAgent with a dedicated method (researcher_call)
      for executing research queries.
    - Custom Runtime: Derived from BaseChatRuntime, ResearchRuntime manages session lifecycle,
      user I/O, and delegates processing of research queries to the Researcher.
    - System Prompt: A simple Pydantic model used to configure the agent instead of a full persona.
    
Usage:
    Run this module to start an interactive research session.
"""
from typing import Optional, Union, List, Dict, Any
from pydantic import BaseModel, Field
from babelgraph.core.agent import BaseAgent
from babelgraph.core.runtime import BaseChatRuntime
from mirascope.core import BaseTool
import logging
import asyncio
import random

# Uncomment and configure when using Lilypad for tracing/debugging.
# import lilypad
# lilypad.configure()

logger = logging.getLogger("ResearchAgent")

class WebSearchTool(BaseTool):
    """
    Mock web search tool.

    Simulates a web search for a given topic by returning random mock results.
    Demonstrates how custom tools can be integrated with the Researcher agent.
    """
    query: str = Field(..., description="Search query to look up")
    
    @classmethod
    def _name(cls) -> str:
        """Return the name of the tool for LLM function calling."""
        return "web_search"
        
    @classmethod
    def _description(cls) -> str:
        """Return a description of the tool for LLM guidance."""
        return "Search the web for information on a topic"
        
    def call(self) -> Dict[str, Any]:
        """
        Execute a mock web search.

        Returns:
            Dict[str, Any]: A dictionary containing mock search results.
        """
        mock_results = [
            {
                "title": f"Research on {self.query}",
                "snippet": f"Recent studies about {self.query} suggest...",
                "url": f"https://example.com/research/{self.query.replace(' ', '-')}"
            },
            {
                "title": f"Latest findings: {self.query}",
                "snippet": f"Experts in {self.query} have discovered...",
                "url": f"https://research.org/papers/{self.query.replace(' ', '_')}"
            }
        ]
        return {"results": random.sample(mock_results, k=1)}

# Define a basic system prompt configuration for the researcher.
class BasicResearcherPrompt(BaseModel):
    """
    Basic system prompt configuration for the researcher agent.
    
    Instructs the agent to provide detailed, fact-based answers for research queries.
    """
    instruction: str = Field(
        default="You are a research assistant that provides detailed, factual answers.",
        description="Instruction for research queries"
    )

BASIC_RESEARCH_PROMPT = BasicResearcherPrompt()

class Researcher(BaseAgent):
    """
    Specialized agent for research tasks.

    Extends BaseAgent by adding a dedicated method, researcher_call, 
    for executing research queries with enhanced logging.
    """
    system_prompt: Optional[Union[str, BasicResearcherPrompt]] = Field(
        default_factory=lambda: BASIC_RESEARCH_PROMPT
    )
    tools: List[type[BaseTool]] = Field(
        default_factory=lambda: [WebSearchTool],
        description="Research tools available to the agent"
    )

    # Optionally, apply tracing decorators (e.g., from Lilypad)
    async def researcher_call(self, query: str) -> str:
        """
        Execute a research query with logging.

        Args:
            query (str): The research query input by the user.
            
        Returns:
            str: The final response generated by processing the query.
        """
        logger.info(f"Starting research on: {query}")
        result = await self._step(query)
        logger.info("Research complete")
        return result

class ResearchRuntime(BaseChatRuntime):
    """
    Specialized runtime for research operations.

    Manages an interactive research session by handling user input, 
    delegating processing of research queries to the Researcher agent, and managing
    session life-cycle events.
    """
    async def process_message(self, message: str) -> str:
        """
        Process a research query by invoking the researcher's researcher_call.

        Args:
            message (str): The research query.
            
        Returns:
            str: The response from the Researcher agent.
            
        Raises:
            Exception: Propagates any exceptions during processing.
        """
        if not self.current_session:
            self._start_session(platform="research")
        try:
            researcher = self.agent
            response = await researcher.researcher_call(message)
            logger.debug(f"Research response: {response}")
            return response
        except Exception as e:
            logger.exception("Error during research")
            raise

    async def start(self) -> None:
        """
        Start the research session.

        Initializes a session, provides guidance to the user, and enters a loop to
        process multiple research queries until termination.
        """
        self._start_session("research")
        logger.info("Starting Research Session")
        logger.info("Ask research questions or type 'exit' to quit")
        print("\n🔍 Research Assistant Ready!")
        print("--------------------------------")
        print("Example queries:")
        print("- 'What are the latest developments in quantum computing?'")
        print("- 'Summarize recent research on climate change'")
        print("--------------------------------\n")
        
        while True:
            try:
                query = input("\nResearch Query: ")
                if query.lower() in ["exit", "quit"]:
                    break
                
                print("\n🔍 Researching...")
                response = await self.process_message(query)
                print(f"\nFindings: {response}")
                
            except KeyboardInterrupt:
                logger.info("Research session interrupted")
                break
            except Exception as e:
                logger.error(f"Research error: {e}")
                print(f"\n[Error] {e}")
        
        await self.stop()
        logger.info("Research session concluded")

    async def stop(self) -> None:
        """
        Clean up the research session.

        Performs any necessary cleanup actions when the research session is concluded.
        """
        logger.info("Cleaning up research session")
        # Add any runtime-specific cleanup here.
        pass

async def main():
    """
    Run the research agent demo.

    Initializes the Researcher agent with its basic system prompt and tools, creates a ResearchRuntime,
    and starts the interactive research session.
    """
    config = BASIC_RESEARCH_PROMPT  # Using the basic research prompt configuration
    researcher = Researcher(
        system_prompt=config,
        tools=[WebSearchTool]
    )
    runtime = ResearchRuntime(researcher)
    await runtime.start()

if __name__ == "__main__":
    asyncio.run(main())
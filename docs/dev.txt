# babelgraph Development Notes

A lightweight graph orchestration library for multi-agent systems, focused on composable workflows and structured outputs.

## Core Concepts

1. **Graphs**: Orchestrate complex workflows through directed graphs
2. **Nodes**: Modular units of work (agents, actions, processing)
3. **State**: Clean data passing between nodes
4. **Agents**: LLM-powered nodes using Mirascope
5. **Tools**: Reusable capabilities for agents

---

## Project Structure

```
src/
├── babelgraph/
│   ├── core/
│   │   ├── agent/
│   │   │   ├── __init__.py
│   │   │   └── base.py          # Provider-agnostic BaseAgent
│   │   ├── graph/
│   │   │   ├── nodes/
│   │   │   │   ├── base/
│   │   │   │   │   ├── __init__.py
│   │   │   │   │   └── node.py  # Base node abstraction
│   │   │   │   ├── __init__.py
│   │   │   │   ├── actions.py   # Action nodes
│   │   │   │   └── agent.py     # Agent nodes
│   │   │   ├── __init__.py
│   │   │   ├── base.py          # Graph framework
│   │   │   ├── state.py         # State management
│   │   │   └── viz.py           # Visualization
│   │   ├── tools/
│   │   │   ├── __init__.py
│   │   │   ├── calculator.py
│   │   │   ├── discord_toolkit.py
│   │   │   └── image_generator.py
│   │   ├── __init__.py
│   │   ├── logging.py           # Centralized logging
│   │   └── runtime.py           # Runtime environments
│   └── extensions/
│       ├── __init__.py
│       └── discord/             # Discord integration
│           ├── __init__.py
│           ├── client.py
│           └── runtime.py
└── tests/                       # Test suite
    ├── __init__.py
    └── core/
        ├── agent/
        │   ├── conftest.py
        │   ├── test_base.py
        │   └── test_runtime.py
        └── graph/
            ├── nodes/
            │   ├── __init__.py
            │   ├── test_actions.py
            │   ├── test_agent.py
            │   └── test_base.py
            ├── __init__.py
            ├── test_base.py
            ├── test_config.py
            └── test_state.py
```

## Core Systems

### 1. Graph System (core/graph/)

The heart of babelgraph, providing workflow orchestration.

**Key Components:**
- `base.py`: Graph framework and orchestration
- `state.py`: State management and data flow
- `nodes/`: Node implementations
  * `base/node.py`: Base node abstraction
  * `actions.py`: Action nodes for custom logic
  * `agent.py`: LLM-powered agent nodes

**Features:**
- Async execution
- State management
- Event emission
- Parallel processing
- Visualization
- Error handling
- Subgraph composition

### 2. Agent System (core/agent/)

LLM integration using Mirascope for structured interactions.

**Key Features:**
- Provider agnostic (OpenAI, Anthropic)
- Structured outputs via Pydantic
- Tool integration
- Streaming support
- System prompts
- Response validation
- OpenPipe integration for custom models

### 3. Logging System (core/logging.py)

Centralized, component-based logging with pretty formatting.

**Features:**
- Component-based configuration
- Pretty console output
- Structured logging
- File output support
- Pydantic integration
- Configurable verbosity levels

### 4. Runtime System (core/runtime.py)

Environment management for different execution contexts.

**Features:**
- Local console runtime
- Platform-specific runtimes (Discord)
- Session management
- Environment configuration
- Tool execution context

---

## Key Design Decisions

1. **Separation of Concerns**
   - Agents handle LLM interactions and structured outputs
   - Graphs manage workflow orchestration and state
   - Runtimes provide platform integration when needed
   - Logging is centralized and component-based

2. **Simplified Processing**
   - AgentNodes call agent._step() directly
   - No need for workflow-specific runtimes
   - Graph handles state management and transitions
   - Parallel execution through graph orchestration
   - Terminal nodes are just regular nodes

3. **State Management**
   - NodeState for passing data between nodes
   - Graph manages parallel execution state
   - Clean state sharing in subgraphs
   - No need for complex runtime state

---

## Common Patterns

### 1. Terminal Nodes
```python
# Simple terminal node
end = Node(
    id="end",
    next_nodes={},  # Empty dict means terminal
    metadata={}     # Optional metadata for node behavior
)
```

### 2. Agent Nodes
Agent nodes require:
- response_model: Pydantic model for structured output
- agent: BaseAgent instance with matching response_model
- next_nodes: Mapping of conditions to next node IDs

Example:
```python
class AnalyzerNode(AgentNode):
    """Agent node for structured analysis."""
    _logger: logging.Logger = PrivateAttr(default_factory=lambda: get_logger(LogComponent.NODES))
    
    def __init__(self, **data):
        super().__init__(
            response_model=AnalysisResponse,  # Required
            **data
        )
    
    async def process(self, state: NodeState) -> Optional[str]:
        try:
            # Get input from state
            message = self.format_prompt(state)
            
            # Process with agent
            response = await self.agent._step(message)
            
            # Validate response type
            if isinstance(response, self.response_model):
                state.results[self.id] = {"response": response}
                return "success"
            
            self._logger.error(f"Invalid response type: {type(response)}")
            return "error"
            
        except Exception as e:
            self._logger.error(f"Process error: {e}")
            state.errors[self.id] = str(e)
            return "error"
```

### 3. Graph Configuration
```python
# Configure logging
configure_logging(
    default_level=LogLevel.INFO,
    component_levels={
        LogComponent.GRAPH: LogLevel.INFO,
        LogComponent.NODES: LogLevel.DEBUG,
        LogComponent.AGENT: LogLevel.DEBUG
    },
    pretty=True  # Enable pretty formatting
)

# Create workflow with config
graph = Graph(
    config=GraphConfig(
        max_parallel=4,    # Maximum parallel nodes
        timeout=60,        # Node timeout in seconds
        retry_count=3      # Number of retries on failure
    )
)

# Add nodes
graph.add_node(start_node)
graph.add_node(process_node)
graph.add_node(Node(id="end", next_nodes={}))

# Set entry point
graph.set_entry_point("start")

# Initialize state
state = NodeState()
state.data["input"] = "Initial data"

# Run graph
final_state = await graph.run("start", state)
```

The key improvements are:

1. Added proper initialization of AgentNode with response_model
2. Added state management in the process method
3. Improved error handling and logging
4. Added more comprehensive graph configuration options
5. Added state initialization example
6. Added proper type hints and docstrings
7. Added metadata field to terminal nodes

Would you like me to expand on any of these patterns or add additional examples?

---

## Example Implementations

1. **Base Agent Examples**
   - Custom tool creation and integration
   - Local console runtime usage
   - Conversation management
   - Custom runtime implementation
   - Structured output with Pydantic

2. **Graph Workflow Examples**
   - Multi-step reasoning
   - Chain-of-thought implementation
   - State management
   - Streaming responses
   - Multi-agent systems
   - Real-time interactions

3. **Platform Integration**
   - Discord chatbots
   - Local message processing
   - Platform-specific tools

---

## Development Guidelines

### Code Style
- Follow PEP 8
- Use type hints
- Document with docstrings
- Use Pydantic models
- Async-first design

### Logging Practices
- Use component loggers
- Configure appropriate levels
- Use PrivateAttr in models
- Keep messages informative
- Log state transitions

### Testing
- Unit test components
- Integration test workflows
- Test error scenarios
- Verify logging
- Check state transitions

---

## Future Development

### High Priority
1. Enhanced state persistence
2. Improved visualization
3. More tool integrations
4. Additional platform support

### In Progress
1. Graph runtime improvements
2. Documentation expansion
3. Testing coverage
4. Error handling enhancements

---

## Contributing

1. Follow the code style guide
2. Add tests for new features
3. Update documentation
4. Use proper logging
5. Consider error cases
6. Keep nodes modular

### Structured Outputs and Graph Workflows

The BaseAgent has been refactored to support structured outputs using Pydantic models and JSON mode. As a result, the graph orchestration system now supports chaining agent and action nodes with structured response data. When linking multiple agent nodes, please ensure that outputs from upstream nodes are serialized as valid JSON (using json.dumps(...)) before being passed to downstream nodes. This guarantees consistency when processing responses and enables advanced features such as streaming responses and executing actions based on structured data.

Users have the flexibility to share agent instances across nodes to preserve state or use independent agents, allowing dynamic workflows ranging from a single node chat to multi-agent collaborations.

### Node Decorators and Helpers

1. **@terminal_node**
   - Marks a node as terminal (no outgoing edges)
   - Automatically sets empty next_nodes
   - Used for end nodes or result display nodes

```python
@terminal_node
class EndNode(Node):
    async def process(self, state):
        # Display or process final results
        return None
```

2. **@state_handler**
   - Handles state transitions and error management
   - Automatically marks node status (running/completed/error)
   - Provides consistent error handling

```python
@state_handler
async def process(self, state):
    # Your processing logic here
    return "success"
```

3. **State Management Helpers**
   - `update_state(state, key, value)`: Update state data
   - `get_state(state, key, default=None)`: Get state value
   - `set_result(state, key, value)`: Store node result
   - `get_result(state, node_id, key, default=None)`: Get node result

### Workflow Composition

1. **Declarative Workflow Creation**
```python
graph.create_workflow(
    nodes={
        "analyze": analyzer,
        "decide": decision,
        "end": end_node
    },
    flows=[
        ("analyze", "success", "decide"),
        ("analyze", "error", "end")
    ]
)
```

2. **Sequential Chaining**
```python
graph.chain([node1, node2, node3])
```

3. **Conditional Branching**
```python
graph.branch(analyzer, {
    "positive": positive_handler,
    "negative": negative_handler
})
```

4. **Path Merging**
```python
graph.merge([path1, path2], final_node)
```

5. **Graph Composition**
```python
main_graph.compose(subgraph, "agent1")
```

### Structured Outputs

The BaseAgent has been refactored to support structured outputs using Pydantic models and JSON mode. When linking multiple agent nodes, please ensure that outputs from upstream nodes are serialized as valid JSON (using model_dump_json()) before being passed to downstream nodes. This guarantees consistency when processing responses and enables advanced features such as streaming responses and executing actions based on structured data.

Users have the flexibility to share agent instances across nodes to preserve state or use independent agents, allowing dynamic workflows ranging from a single node chat to multi-agent collaborations.

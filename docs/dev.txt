# babelgraph Development Notes

A lightweight graph orchestration library for multi-agent systems, focused on composable workflows and structured outputs.

## Core Concepts

1. **Graphs**: Orchestrate complex workflows through directed graphs
2. **Nodes**: Modular units of work (agents, actions, processing)
3. **State**: Clean data passing between nodes
4. **Agents**: LLM-powered nodes using Mirascope
5. **Tools**: Reusable capabilities for agents

---

## Project Structure

```
src/
├── babelgraph/
│   ├── core/
│   │   ├── agent/
│   │   │   ├── __init__.py
│   │   │   └── base.py          # Provider-agnostic BaseAgent
│   │   ├── graph/
│   │   │   ├── nodes/
│   │   │   │   ├── base/
│   │   │   │   │   ├── __init__.py
│   │   │   │   │   └── node.py  # Base node abstraction
│   │   │   │   ├── __init__.py
│   │   │   │   ├── actions.py   # Action nodes
│   │   │   │   └── agent.py     # Agent nodes
│   │   │   ├── __init__.py
│   │   │   ├── base.py          # Graph framework
│   │   │   ├── state.py         # State management
│   │   │   └── viz.py           # Visualization
│   │   ├── tools/
│   │   │   ├── __init__.py
│   │   │   ├── calculator.py
│   │   │   ├── discord_toolkit.py
│   │   │   └── image_generator.py
│   │   ├── __init__.py
│   │   ├── logging.py           # Centralized logging
│   │   └── runtime.py           # Runtime environments
│   └── extensions/
│       ├── __init__.py
│       └── discord/             # Discord integration
│           ├── __init__.py
│           ├── client.py
│           └── runtime.py
└── tests/                       # Test suite
    ├── __init__.py
    └── core/
        ├── agent/
        │   ├── conftest.py
        │   ├── test_base.py
        │   └── test_runtime.py
        └── graph/
            ├── nodes/
            │   ├── __init__.py
            │   ├── test_actions.py
            │   ├── test_agent.py
            │   └── test_base.py
            ├── __init__.py
            ├── test_base.py
            ├── test_config.py
            └── test_state.py
```

## Core Systems

### 1. Graph System (core/graph/)

The heart of babelgraph, providing workflow orchestration.

**Key Components:**
- `base.py`: Graph framework and orchestration
- `state.py`: State management and data flow
- `nodes/`: Node implementations
  * `base/node.py`: Base node abstraction
  * `actions.py`: Action nodes for custom logic
  * `agent.py`: LLM-powered agent nodes

**Features:**
- Async execution
- State management
- Event emission
- Parallel processing
- Visualization
- Error handling
- Subgraph composition

### 2. Agent System (core/agent/)

LLM integration using Mirascope for structured interactions.

**Key Features:**
- Provider agnostic (OpenAI, Anthropic)
- Structured outputs via Pydantic
- Tool integration
- Streaming support
- System prompts
- Response validation
- OpenPipe integration for custom models

### 3. Logging System (core/logging.py)

Centralized, component-based logging with pretty formatting.

**Features:**
- Component-based configuration
- Pretty console output
- Structured logging
- File output support
- Pydantic integration
- Configurable verbosity levels

### 4. Runtime System (core/runtime.py)

Environment management for different execution contexts.

**Features:**
- Local console runtime
- Platform-specific runtimes (Discord)
- Session management
- Environment configuration
- Tool execution context

---

## Key Design Decisions

1. **Separation of Concerns**
   - Agents handle LLM interactions and structured outputs
   - Graphs manage workflow orchestration and state
   - Runtimes provide platform integration when needed
   - Logging is centralized and component-based

2. **Simplified Processing**
   - AgentNodes call agent._step() directly
   - No need for workflow-specific runtimes
   - Graph handles state management and transitions
   - Parallel execution through graph orchestration
   - Terminal nodes are just regular nodes

3. **State Management**
   - NodeState for passing data between nodes
   - Graph manages parallel execution state
   - Clean state sharing in subgraphs
   - No need for complex runtime state

---

## Common Patterns

### 1. Terminal Nodes
```python
# Simple terminal node
end = Node(
    id="end",
    next_nodes={}  # Empty dict means terminal
)
```

### 2. Agent Nodes
```python
class AnalyzerNode(AgentNode):
    _logger: logging.Logger = PrivateAttr()
    
    async def process(self, state: NodeState) -> Optional[str]:
        try:
            response = await self.agent._step(message)
            if isinstance(response, self.response_model):
                return "success"
            return "error"
        except Exception as e:
            self._logger.error(f"Process error: {e}")
            return "error"
```

### 3. Graph Configuration
```python
# Configure logging
configure_logging(
    LogLevel.INFO,
    component_levels={
        LogComponent.GRAPH: LogLevel.INFO,
        LogComponent.NODES: LogLevel.DEBUG
    }
)

# Create workflow
graph = Graph()
graph.add_node(start_node)
graph.add_node(process_node)
graph.add_node(Node(id="end", next_nodes={}))
graph.set_entry_point("start")
```

---

## Example Implementations

1. **Base Agent Examples**
   - Custom tool creation and integration
   - Local console runtime usage
   - Conversation management
   - Custom runtime implementation
   - Structured output with Pydantic

2. **Graph Workflow Examples**
   - Multi-step reasoning
   - Chain-of-thought implementation
   - State management
   - Streaming responses
   - Multi-agent systems
   - Real-time interactions

3. **Platform Integration**
   - Discord chatbots
   - Local message processing
   - Platform-specific tools

---

## Development Guidelines

### Code Style
- Follow PEP 8
- Use type hints
- Document with docstrings
- Use Pydantic models
- Async-first design

### Logging Practices
- Use component loggers
- Configure appropriate levels
- Use PrivateAttr in models
- Keep messages informative
- Log state transitions

### Testing
- Unit test components
- Integration test workflows
- Test error scenarios
- Verify logging
- Check state transitions

---

## Future Development

### High Priority
1. Enhanced state persistence
2. Improved visualization
3. More tool integrations
4. Additional platform support

### In Progress
1. Graph runtime improvements
2. Documentation expansion
3. Testing coverage
4. Error handling enhancements

---

## Contributing

1. Follow the code style guide
2. Add tests for new features
3. Update documentation
4. Use proper logging
5. Consider error cases
6. Keep nodes modular
